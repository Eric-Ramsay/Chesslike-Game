//AI Functions----------------------------------------------------------------------
	void run_turn() {
		//This should really be an enum on the classes page
		int farm = 0; int house = 1; int windmill = 2; int fort = 3;

		int unit_values[8] = { 0, 0, 0, 0, 0, 0, 0, 0 }; //Relative strength of other players
		int unit_p[7] = { 0, 0, 0, 0, 0, 0, 0 }; //Priority for purchasing units
		int building_p[4] = { 25, 0, 0, 0 }; //Priority for buying buildings
		int b_costs[4] = { 1, 3, 8, 8 }; //Priority for buying buildings
		int my_val = 0;
		
		bool stop = false;
		bool has_commander = false;
		int runs = 0; // Used for preventing infinite loops in while statements

		int index = 0; // used for placing buildings/units
		C c(-1, -1);

		int bIndex = 0; //Tells what building is being bought
		//
		//I should make a function to initialize these two vectors, so that when say a commander is moved or a peasant is placed, the list of tiles updates
		//
		std::vector<C> can_place = {};
		std::vector<C> can_placeB = {};
		
		//Evaluate enemy threat level
		for (int i = 0; i < MAPSIZE; i++) {
			for (int j = 0; j < MAPSIZE; j++) {
				if (map[i][j].unit.owner > 0) {
					unit_values[map[i][j].unit.owner - 1] += units[map[i][j].unit.type - 1].cost;
					if (map[i][j].unit.owner != p.turn) {
						switch (map[i][j].unit.type) {
						case 1: unit_p[0] += 5; building_p[farm] += 5; building_p[windmill] += 5; break; //Peasant
						case 2: unit_p[2] += 5; unit_p[3] += 5; unit_p[4] += 5; break; //Spearmen
						case 3: unit_p[2] += 5; unit_p[5] += 5; break; //Archers
						case 4: unit_p[2] += 5; unit_p[3] += 5; break; //Heavy Inf
						case 5: unit_p[5] += .1; unit_p[2] -= 5; break; //CA
						case 6: unit_p[1] += 5; unit_p[4] -= 5; break; //Light Cav
						case 7: unit_p[3] += 5; unit_p[6] += 5; break; //Heavy Cav
						}
					}
					else {
						if (map[i][j].unit.type >= 8) { //Flag showing that the AI can place a commander, thus can buy units
							has_commander = true;
						}
						else if (map[i][j].unit.type == 1) {
							unit_p[0] -= 10;
						}
					}
				}
				else if (canBuy(j, i, 0)) { //Check if unit can be placed on this tile
					can_place.push_back(C(j, i));
				}
				if (canBuyBuilding(j, i, 0)) { //Check if building can be placed on this tile
					can_placeB.push_back(C(j, i));
				}
			}
		}
		if (!p.started) { //Place the commander somewhere
			runs = 0;
			while (!p.started && runs < 100) {
				stop = false;
				c = can_place[rand() % can_place.size()];
				for (int a = -1; a < 2; a++) {
					for (int b = -1; b < 2; b++) {
						if (map[safeC(a + c.y)][safeC(b + c.x)].elev != FLAT || map[safeC(a + c.y)][safeC(b + c.x)].forest != NONE) {
							stop = true;
							a = 2; b = 2;
						}
					}
				}
				if (!stop) {
					p.started = true;
					p.units.push_back(c);
					map[c.y][c.x].owner = p.turn;
					map[c.y][c.x].unit.type = 9;
					map[c.y][c.x].unit.owner = p.turn;
					map[c.y][c.x].unit.HP = units[8].HP;
					map[c.y][c.x].unit.MP = 0;
					sendData("u" + sendUnit(tH.x, tH.y));
					run_turn(); //Run this function again
				}
			}
		}
		else { //Do your turn as normal
			for (int i = 0; i < 7; i++) { //Give priority to unit purchasing based on what AI can buy
				if (p.gold >= units[i].cost) {
					unit_p[i] += 15 + i * 5;
				}
				else {
					unit_p[i] = 0;
				}
			}
			my_val = unit_values[p.turn - 1];
			int max = 0;
			for (int i = 0; i < 8; i++) {
				if (i != (p.turn - 1)) {
					if (unit_values[i] > max) {
						max = unit_values[i];
					}
				}
			}

			//Evaluate Buildings
			if (has_commander) {
				if (p.units.size() >= p.max_pop && p.gold >= 3) {
					building_p[house] = 90;
				}
				if (max < 2 * my_val && p.gold >= 8) {
					building_p[windmill] = 70;
				}
				runs = 0;
				while (p.gold > 0 && !stop) {
					runs++;
					//Decide what to do
					if (p.max_pop > p.units.size() && can_place.size() > 0) {//Buy Units
						for (int i = 6; i >= 0; i--) { 
							if (p.gold >= units[i].cost && rand() % 100 < unit_p[i]) {
								int ape = 0;
								do {
									index = rand() % can_place.size();
								} while (can_place[index].x == -1 && ape++ < can_place.size());
								if (ape < can_place.size()) { //Buy a unit
									c = can_place[index];
									p.gold -= units[i].cost;
									p.units.push_back(c);
									map[c.y][c.x].owner = p.turn;
									map[c.y][c.x].unit.type = i + 1;
									map[c.y][c.x].unit.owner = p.turn;
									map[c.y][c.x].unit.HP = getMaxHP(i + 1, p.turn);
									map[c.y][c.x].unit.MP = 0;
									sendData("u" + sendUnit(c.x, c.y));
									can_place[index].x = -1;
									unit_p[i] -= 10;
									i = 6;
								}
							}
						}
					}
					//Buy Buildings
					if (can_placeB.size() > 0) {
						for (int i = 0; i < 4; i++) { //Buy buildings
							index = -1;
							bIndex = i;
							if (p.gold >= b_costs[i] && rand() % 100 < building_p[i]) {
								//I want to build this building, find a tile to build it on
								int ape = 0;
								do {
									index = rand() % can_placeB.size();
									c = can_placeB[index];
									if (c.x != -1) {
										if (i != farm && i != fort) { //Windmill or house
											stop = (i != windmill);
											for (int a = -1; a < 2; a++) {
												for (int b = -1; b < 2; b++) {
													if (map[safeC(a + c.y)][safeC(b + c.x)].elev != FLAT || map[safeC(a + c.y)][safeC(b + c.x)].forest != NONE) {
														stop = (i == windmill);
														a = 2; b = 2;
													}
												}
											}
											if (stop) {
												can_placeB[index].x = -1;
												index = -1;
											}
											else {
												bIndex = i;
											}
										}
									}
								} while ((index == -1 || can_placeB[index].x == -1) && ape++ < can_placeB.size());
								if (ape >= can_placeB.size()) {
									index = -1;
								}
							}
							if (index > -1 && bIndex > -1) {
								c = can_placeB[index];
								if (bIndex == 0) { //Farm
									p.gold -= 1;
									map[c.y][c.x].building = 1;
								}
								else if (bIndex == 1) { //House
									map[c.y][c.x].building = 5;
									p.gold -= 3;
								}
								else if (bIndex == 2) { //Windmill
									map[c.y][c.x].building = 6;
									p.gold -= 8;
								}
								else if (bIndex == 3) { //Fort
									map[c.y][c.x].building = 7;
									p.gold -= 8;
								}
								p.buildings.push_back(c);
								map[c.y][c.x].owner = p.turn;
								sendData("b" + sendBuilding(c.x, c.y));
							}
						}
					}
					
					if (runs >= 10 || (p.gold <= 4 && rand() % 10 == 0)) {
						stop = true;
					}
				}
			}
			else {
				for (int i = p.units.size() - 1; i >= 0; i--) {
					C c = p.units[i];
					if (map[c.y][c.x].unit.owner == p.turn && !(units[map[c.y][c.x].unit.type - 1].naval)) { //Promote Commander
						if (p.gold >= (16 - units[map[c.y][c.x].unit.type - 1].cost)) {
							p.gold -= (16 - units[map[c.y][c.x].unit.type - 1].cost);
							map[c.y][c.x].unit.type = 8;
							map[c.y][c.x].unit.HP = 20;
							map[c.y][c.x].unit.MP = 0;
							sendData("u" + sendUnit(c.x, c.y));
							i = p.units.size();
						}
					}
				}
			}
		}
	}
	//End AI--------------------------------------------------------------------------------
